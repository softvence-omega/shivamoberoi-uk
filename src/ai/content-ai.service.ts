import { Injectable, Inject, Logger, HttpException, HttpStatus } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import OpenAI from 'openai';
import { ConfigService } from '@nestjs/config';
import { Content, ContentDocument } from 'src/schemas/content.schema';
import { v4 as uuidv4 } from 'uuid';

export interface ContentAnalysis {
  readabilityScore: number;
  keywordDensity: number;
  issues: string[];
  keywords?: string[];
}

export interface ContentResult {
  url: string;
  content: string;
  analysis: ContentAnalysis;
}

@Injectable()
export class ContentAiService {
  private readonly logger = new Logger(ContentAiService.name);
  private readonly openai: OpenAI;
  private readonly config = {
    cacheTtl: 3600,
    maxRetries: 3,
    retryDelay: 1000,
    model: 'gpt-3.5-turbo',
    maxTokens: 500,
    temperature: 0.7,
  };

  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    @InjectModel(Content.name) private readonly contentModel: Model<ContentDocument>,
    private readonly configService: ConfigService,
  ) {
    const apiKey = this.configService.get<string>('OPENAI_API_KEY') || process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY is not set in the environment variables');
    }
    this.logger.debug(`Loaded API Key: ${apiKey.substring(0, 5)}...`);
    this.openai = new OpenAI({ apiKey });
  }

  async generateContent(url: string, prompt: string): Promise<{ status: string; message: string; data: ContentResult }> {
    const cacheKey = `content_generate_${url}_${prompt.substring(0, 20)}`;
    try {
      const cached = await this.cacheManager.get<{ status: string; message: string; data: ContentResult }>(cacheKey);
      if (cached) {
        this.logger.debug(`Returning cached content for ${url} and prompt: ${prompt.substring(0, 20)}...`);
        return cached;
      }

      const generatedContent = await this.retryableAiCall(prompt, 700, 0.7); // Increased maxTokens for detailed response
      if (!generatedContent) {
        throw new Error('No content generated by OpenAI');
      }

      const keywords = this.extractKeywords(generatedContent);
      const analysis = await this.analyzeContent(generatedContent, keywords);

      const uniqueUrl = `custom-prompt-${uuidv4()}`;
      const content = await this.contentModel.create({
        url: uniqueUrl,
        originalContent: '',
        generatedContent,
        analysis,
      }).catch(dbError => {
        this.logger.error(`Database error in content creation: ${dbError.message}`, dbError.stack);
        throw new Error(`Database error: ${dbError.message}`);
      });

      const result: ContentResult = this.formatResult(uniqueUrl, generatedContent, analysis);
      const response = {
        state: "true",
        status: 'success',
        message: 'Content generated successfully',
        data: result,
      };
      await this.cacheManager.set(cacheKey, response, this.config.cacheTtl).catch(cacheError => {
        this.logger.warn(`Failed to cache result: ${cacheError.message}`);
      });
      return response;
    } catch (err) {
      this.logger.error(`Failed generating content for ${url} and prompt: ${prompt.substring(0, 20)}...: ${err.message}`, err.stack);
      if (err.message.includes('429') || err.message.includes('quota')) {
        throw new HttpException(
          {
            status: HttpStatus.TOO_MANY_REQUESTS,
            error: 'Quota Exceeded',
            message: 'You have exceeded your OpenAI API quota. Please add credits or check your plan and billing details at https://platform.openai.com/account/billing.',
          },
          HttpStatus.TOO_MANY_REQUESTS
        );
      }
      throw new HttpException(`Content generation failed: ${err.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  async refineContent(url: string, content: string): Promise<{ status: string; message: string; data: ContentResult }> {
    const cacheKey = `content_refine_${url}`;
    try {
      const cached = await this.cacheManager.get<{ status: string; message: string; data: ContentResult }>(cacheKey);
      if (cached) {
        this.logger.debug(`Returning cached refined content for ${url}`);
        return cached;
      }

      const existingContent = await this.contentModel.findOne({ url })
        .lean<{ analysis?: ContentAnalysis & { keywords?: string[] } }>()
        .exec().catch(dbError => {
          this.logger.error(`Database error finding content: ${dbError.message}`, dbError.stack);
          throw new Error(`Database error: ${dbError.message}`);
        });

      const keywords = existingContent?.analysis?.keywords 
        ? [...existingContent.analysis.keywords] 
        : this.extractKeywords(content);

      const analysis = await this.analyzeContent(content, keywords);

      const prompt = this.buildRefinementPrompt(content, keywords, analysis.issues);
      const refinedContent = await this.retryableAiCall(prompt);
      if (!refinedContent) {
        throw new Error('No refined content generated by OpenAI');
      }

      const updatedContent = await this.contentModel.findOneAndUpdate(
        { url },
        {
          originalContent: content,
          generatedContent: refinedContent,
          analysis: { ...analysis, keywords },
          updatedAt: new Date(),
        },
        { upsert: true, new: true, lean: true }
      ).catch(dbError => {
        this.logger.error(`Database error updating content: ${dbError.message}`, dbError.stack);
        throw new Error(`Database error: ${dbError.message}`);
      });

      const result: ContentResult = this.formatResult(url, refinedContent, analysis);
      const response = {
        state: 'true', 
        status: 'successfully genereated',
        message: 'Content refined successfully',
        data: result,
      };
      await this.cacheManager.set(cacheKey, response, this.config.cacheTtl).catch(cacheError => {
        this.logger.warn(`Failed to cache refined result: ${cacheError.message}`);
      });
      return response;
    } catch (err) {
      this.logger.error(`Failed to refine content for ${url}: ${err.message}`, err.stack);
      if (err.message.includes('429') || err.message.includes('quota')) {
        throw new HttpException(
          {
            status: HttpStatus.TOO_MANY_REQUESTS,
            error: 'Quota Exceeded',
            message: 'You have exceeded your OpenAI API quota. Please add credits or check your plan and billing details at https://platform.openai.com/account/billing.',
          },
          HttpStatus.TOO_MANY_REQUESTS
        );
      }
      throw new HttpException(`Content refinement failed: ${err.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
async analyzeContent(content: string, keywords?: string[]): Promise<ContentAnalysis> {
  const effectiveKeywords = keywords?.length ? keywords : this.extractKeywords(content);

  const prompt = this.buildAnalysisPrompt(content, effectiveKeywords);

  try {
    const response = await this.retryableAiCall(prompt, 150, 0.3);
    return this.parseAnalysisResponse(response);
  } catch (error) {
    this.logger.warn(`AI analysis failed, using fallback: ${error.message}`, error.stack);
    return this.fallbackAnalysis(content, effectiveKeywords);
  }
}

  //  async analyzeContent(content: string, keywords: string[]): Promise<ContentAnalysis> {
  //   const prompt = this.buildAnalysisPrompt(content, keywords);
  //   try {
  //     const response = await this.retryableAiCall(prompt, 150, 0.3);
  //     return this.parseAnalysisResponse(response);
  //   } catch (error) {
  //     this.logger.warn(`AI analysis failed, using fallback: ${error.message}`, error.stack);
  //     return this.fallbackAnalysis(content, keywords);
  //   }
  // }

  private fallbackAnalysis(content: string, keywords: string[]): ContentAnalysis {
    const wordCount = content.split(/\s+/).length;
    const keywordMatches = keywords.reduce((count, kw) => 
      count + (content.toLowerCase().split(kw.toLowerCase()).length - 1), 0);
    
    return {
      readabilityScore: Math.min(90, Math.max(60, wordCount / 3)),
      keywordDensity: keywords.length > 0 ? (keywordMatches / wordCount) * 100 : 0,
      issues: wordCount < 150 ? ['Content too short'] : [],
    };
  }

  private parseAnalysisResponse(response: string): ContentAnalysis {
    try {
      const parsed = JSON.parse(response);
      if (!parsed || typeof parsed !== 'object') {
        throw new Error('Invalid JSON structure');
      }
      return {
        readabilityScore: Math.min(100, Math.max(0, parsed.readabilityScore || 50)),
        keywordDensity: Math.min(100, Math.max(0, parsed.keywordDensity || 0)),
        issues: Array.isArray(parsed.issues) ? parsed.issues : [],
      };
    } catch (error) {
      this.logger.error(`Failed to parse analysis response: ${error.message}`, error.stack);
      throw new Error(`Invalid analysis response: ${error.message}`);
    }
  }

  private extractKeywords(content: string): string[] {
    try {
      const words = content.toLowerCase().match(/\b\w{4,}\b/g) || [];
      return [...new Set(words)].slice(0, 5);
    } catch (error) {
      this.logger.warn(`Failed to extract keywords: ${error.message}`, error.stack);
      return [];
    }
  }

  private async retryableAiCall(
    prompt: string,
    maxTokens: number = this.config.maxTokens,
    temperature: number = this.config.temperature,
  ): Promise<string> {
    let lastError: Error | null = null;
    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        const response = await this.openai.chat.completions.create({
          model: this.config.model,
          messages: [{ role: 'user', content: prompt }],
          max_tokens: maxTokens,
          temperature,
        });
        if (!response.choices || !response.choices[0]?.message?.content) {
          throw new Error('No valid content in OpenAI response');
        }
        return response.choices[0].message.content.trim();
      } catch (err) {
        lastError = err as Error;
        const errorMessage = err.message || 'Unknown error';
        if (err.response?.status === 429) {
          this.logger.error(`Quota exceeded (429) on attempt ${attempt}/${this.config.maxRetries} for prompt: ${prompt.substring(0, 50)}...`, err.stack);
          throw new Error('Quota exceeded: You have exceeded your OpenAI API quota. Please add credits or check your plan at https://platform.openai.com/account/billing.');
        }
        if (attempt < this.config.maxRetries) {
          this.logger.warn(`Retrying AI call (${attempt}/${this.config.maxRetries}) for prompt: ${prompt.substring(0, 50)}...`, errorMessage);
          await new Promise((resolve) => setTimeout(resolve, this.config.retryDelay));
        } else {
          this.logger.error(`AI call failed after ${this.config.maxRetries} retries for prompt: ${prompt.substring(0, 50)}...`, err.stack);
        }
      }
    }
    throw lastError || new Error('AI call failed after retries');
  }

  private buildRefinementPrompt(content: string, keywords: string[], issues: string[]): string {
    return `Improve this content for SEO while keeping its original meaning. 
    Keywords: ${keywords.join(', ')}. 
    Fix these issues: ${issues.join('; ')}. 
    Original content: ${content}. 
    Maintain 200-250 word count and add markdown formatting if needed.`;
  }
  private buildAnalysisPrompt(content: string, keywords: string[]): string {
  return `Analyze this content for SEO. Return detailed JSON with:
  - "readabilityScore" (0-100)
  - "keywordDensity" (percentage of how often keywords appear)
  - "issues" (array of detailed explanations of issues)

  Content: ${content}
  Keywords: ${keywords.join(', ')}

  Respond ONLY with valid JSON. For example:
  {
    "readabilityScore": 78,
    "keywordDensity": 2.1,
    "issues": [
      "Content is too short — aim for at least 300 words.",
      "Keyword 'AI' used only once — recommended 2–3 times.",
      "Lacks clear introduction or headings."
    ]
  }`;
}


  // private buildAnalysisPrompt(content: string, keywords: string[]): string {
  //   return `Analyze this content for SEO and return JSON with these properties:
  //   - "readabilityScore": (0-100)
  //   - "keywordDensity": (percentage for ${keywords.join(', ')})
  //   - "issues": (array of issues found)
  //   Content: ${content}.
  //   Return valid JSON only. Example: {"readabilityScore": 85, "keywordDensity": 2.5, "issues": ["short content"]}`;
  // }

  private formatResult(url: string, content: string, analysis: ContentAnalysis): ContentResult {
    return { url, content, analysis };
  }
}

// import { Injectable, Inject, Logger } from '@nestjs/common';
// import { CACHE_MANAGER } from '@nestjs/cache-manager';
// import { Cache } from 'cache-manager';
// import { InjectModel } from '@nestjs/mongoose';
// import { Model } from 'mongoose';
// import OpenAI from 'openai'; // Changed import
// import { ConfigService } from '@nestjs/config';
// import { Content, ContentDocument } from 'src/schemas/content.schema';

//  export interface ContentAnalysis {
//   readabilityScore: number;
//   keywordDensity: number;
//   issues: string[];
//    keywords?: string[];
// }

// export interface ContentResult {
//   url: string;
//   content: string;
//   analysis: ContentAnalysis;

// }

// @Injectable()
// export class ContentAiService {
//   private readonly logger = new Logger(ContentAiService.name);
//   private readonly openai: OpenAI; // Changed type
//   private readonly config = {
//     cacheTtl: 3600,
//     maxRetries: 3,
//     retryDelay: 1000,
//     model: 'gpt-3.5-turbo',
//     maxTokens: 300,
//     temperature: 0.7,
//   };

//   constructor(
//     @Inject(CACHE_MANAGER) private cacheManager: Cache,
//     @InjectModel(Content.name)
//     private readonly contentModel: Model<ContentDocument>,
//     private readonly configService: ConfigService,
//   ) {
//     const apiKey = this.configService.get<string>('OPENAI_API_KEY') || process.env.OPENAI_API_KEY;
//     if (!apiKey) {
//       throw new Error('OPENAI_API_KEY is not set in the environment variables');
//     }
//     this.openai = new OpenAI({ apiKey }); 
//   }

//   async generateContent(
//     url: string,
//     keywords: string[], 
//   ): Promise<ContentResult> {
//     const cacheKey = `content_generate_${url}`;
//     try {
//       const cached = await this.cacheManager.get<ContentResult>(cacheKey);
//       if (cached) {
//         this.logger.debug(`Returning cached content for ${url}`);
//         return cached;
//       }

//       const prompt = this.buildGenerationPrompt(url, keywords);
//       const generatedContent = await this.retryableAiCall(prompt);
//       const analysis = await this.analyzeContent(generatedContent, keywords);

//       const content = await this.contentModel.create({
//         url,
//         originalContent: '',
//         generatedContent,
//         analysis,
//       });

//       const result = this.formatResult(url, generatedContent, analysis);
//       await this.cacheManager.set(cacheKey, result, this.config.cacheTtl);
//       return result;
//     } catch (err) {
//       this.logger.error(`Failed generating content for ${url}: ${err.message}`);
//       throw new Error(`Content generation failed: ${err.message}`);
//     }
//   }
//  async refineContent(url: string, content: string): Promise<ContentResult> {
//     const cacheKey = `content_refine_${url}`;
//     try {
//         const cached = await this.cacheManager.get<ContentResult>(cacheKey);
//         if (cached) {
//             this.logger.debug(`Returning cached refined content for ${url}`);
//             return cached;
//         }

       
//         const existingContent = await this.contentModel.findOne({ url })
//             .lean<{ analysis?: ContentAnalysis & { keywords?: string[] } }>()
//             .exec();

        
//         const keywords = existingContent?.analysis?.keywords 
//             ? [...existingContent.analysis.keywords] 
//             : this.extractKeywords(content);

        
//         const analysis = await this.analyzeContent(content, keywords);
        
        
//         const prompt = this.buildRefinementPrompt(
//             content,
//             keywords,
//             analysis.issues
//         );
//         const refinedContent = await this.retryableAiCall(prompt);
//         const updatedContent = await this.contentModel.findOneAndUpdate(
//             { url },
//             {
//                 originalContent: content,
//                 generatedContent: refinedContent,
//                 analysis: {
//                     ...analysis,
//                     keywords 
//                 },
//                 updatedAt: new Date(),
//             },
//             { upsert: true, new: true, lean: true }
//         );

//         const result = this.formatResult(url, refinedContent, analysis);
//         await this.cacheManager.set(cacheKey, result, this.config.cacheTtl);
//         return result;
//     } catch (err) {
//         this.logger.error(`Failed to refine content for ${url}: ${err.message}`);
//         throw new Error(`Content refinement failed: ${err.message}`);
//     }
// }
//   private async analyzeContent(
//     content: string,
//     keywords: string[],
//   ): Promise<ContentAnalysis> {
//     const prompt = this.buildAnalysisPrompt(content, keywords);
//     try {
//       const response = await this.retryableAiCall(prompt, 150, 0.3);
//       return this.parseAnalysisResponse(response);
//     } catch (error) {
//       this.logger.warn(`AI analysis failed, using fallback: ${error.message}`);
//       return this.fallbackAnalysis(content, keywords);
//     }
//   }
// private fallbackAnalysis(content: string, keywords: string[]): ContentAnalysis {
//     const wordCount = content.split(/\s+/).length;
//     const keywordMatches = keywords.reduce((count, kw) => 
//       count + (content.toLowerCase().split(kw.toLowerCase()).length - 1), 0);
    
//     return {
//       readabilityScore: Math.min(90, Math.max(60, wordCount / 3)),
//       keywordDensity: keywords.length > 0 ? (keywordMatches / wordCount) * 100 : 0,
//       issues: wordCount < 150 ? ['Content too short'] : [],
//     };
//   }
//     private parseAnalysisResponse(response: string): ContentAnalysis {
//     try {
//       const parsed = JSON.parse(response);
//       return {
//         readabilityScore: Math.min(100, Math.max(0, parsed.readabilityScore || 50)),
//         keywordDensity: Math.min(100, Math.max(0, parsed.keywordDensity || 0)),
//         issues: Array.isArray(parsed.issues) ? parsed.issues : [],
//       };
//     } catch (error) {
//       throw new Error(`Invalid analysis response: ${error.message}`);
//     }
//   }

//   private extractKeywords(content: string): string[] {
//     // Fallback heuristic if AI fails
//     const words = content.toLowerCase().match(/\b\w{4,}\b/g) || [];
//     return [...new Set(words)].slice(0, 5);
//   }

//   private async retryableAiCall(
//     prompt: string,
//     maxTokens: number = this.config.maxTokens,
//     temperature: number = this.config.temperature,
//   ): Promise<string> {
//     let lastError: Error | null = null;
//     for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
//       try {
//         const response = await this.openai.chat.completions.create({
//           model: this.config.model,
//           messages: [{ role: 'user', content: prompt }],
//           max_tokens: maxTokens,
//           temperature,
//         });
//         return response.choices[0].message?.content?.trim() || '';
//       } catch (err) {
//         lastError = err as Error;
//         if (attempt < this.config.maxRetries) {
//           this.logger.warn(
//             `Retrying AI call (${attempt}/${this.config.maxRetries})...`,
//           );
//           await new Promise((resolve) =>
//             setTimeout(resolve, this.config.retryDelay),
//           );
//         }
//       }
//     }
//     throw lastError || new Error('AI call failed after retries');
//   }

//   private buildRefinementPrompt(content: string, keywords: string[], issues: string[]): string {
//     return `Improve this content for SEO while keeping its original meaning. 
//     Keywords: ${keywords.join(', ')}. 
//     Fix these issues: ${issues.join('; ')}. 
//     Original content: ${content}. 
//     Maintain 200-250 word count and add markdown formatting if needed.`;
//   }

//   private buildGenerationPrompt(url: string, keywords: string[]): string {
//     return `Generate SEO-optimized content (200-300 words) for ${url} using these keywords naturally: ${keywords.join(', ')}.
//             Include engaging introduction, detailed body, and clear conclusion.
//             Use subheadings (H2, H3) where appropriate.`;
//   }

//   private buildAnalysisPrompt(content: string, keywords: string[]): string {
//     return `Analyze this content for SEO and return JSON with these properties:
//     - "readabilityScore": (0-100)
//     - "keywordDensity": (percentage for ${keywords.join(', ')})
//     - "issues": (array of issues found)
//     Content: ${content}.
//     Return valid JSON only. Example: {"readabilityScore": 85, "keywordDensity": 2.5, "issues": ["short content"]}`;
//   }

//   private formatResult(
//     url: string,
//     content: string,
//     analysis: ContentAnalysis,
//   ): ContentResult {
//     return { url, content, analysis };
//   }
// }
